/**
 * ObjectQL
 * Copyright (c) 2026-present ObjectStack Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import * as fs from 'fs';
import * as path from 'path';
import { loadObjectConfigs } from '@objectql/platform-node';
import { ObjectConfig, FieldConfig } from '@objectql/types';

export async function generateTypes(sourceDir: string, outputDir: string) {
    console.log(`Searching for objects in ${sourceDir}...`);
    
    // Use Loader to get Merged Objects (Flat list)
    let schemas: Record<string, ObjectConfig>;
    try {
        schemas = loadObjectConfigs(sourceDir);
    } catch (e) {
        console.error('Failed to load object configs:', e);
        return;
    }

    if (Object.keys(schemas).length === 0) {
        console.log('No object files found.');
        return;
    }

    // Ensure output dir exists
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    const indexContent: string[] = [];

    for (const [name, schema] of Object.entries(schemas)) {
        try {
            const typeName = toPascalCase(name);
            const typeDefinition = generateInterface(typeName, schema);
            
            // Generate flat files based on Object Name
            // e.g. User.ts, CrmContact.ts
            // We lose original directory structure but gain correct merged types.
            // This is arguably better for "Generated Types" which are usually a flat library.
            
            const fileName = `${name}.ts`;
            const outPath = path.join(outputDir, fileName);
            fs.writeFileSync(outPath, typeDefinition);
            console.log(`Generated ${fileName}`);

            indexContent.push(`export * from './${name}';`);
        } catch (e) {
            console.error(`Failed to generate type for ${name}:`, e);
        }
    }

    // Generate index.ts
    fs.writeFileSync(path.join(outputDir, 'index.ts'), indexContent.join('\n'));
    console.log(`Generated types in ${outputDir}`);
}

function generateInterface(typeName: string, schema: ObjectConfig): string {
    const fields = schema.fields || {};
    const lines = [
        `// Auto-generated by ObjectQL. DO NOT EDIT.`,
        `import { ObjectDoc } from '@objectql/types';`, // Assuming a base type exists or we define it
        ``,
        `export interface ${typeName} extends ObjectDoc {`
    ];

    for (const [key, field] of Object.entries(fields)) {
        const fieldName = field.name || key;
        const isOptional = !field.required;
        const tsType = mapFieldTypeToTs(field);
        
        // Add JSDoc
        if (field.label || field.description) {
            lines.push(`    /**`);
            if (field.label) lines.push(`     * ${field.label}`);
            if (field.description) lines.push(`     * ${field.description}`);
            lines.push(`     */`);
        }
        
        lines.push(`    ${fieldName}${isOptional ? '?' : ''}: ${tsType};`);
    }

    lines.push(`}`);
    lines.push(``);
    return lines.join('\n');
}

function mapFieldTypeToTs(field: FieldConfig): string {
    switch (field.type) {
        case 'text':
        case 'textarea':
        case 'markdown':
        case 'html':
        case 'email':
        case 'phone':
        case 'url':
        case 'password':
        case 'select': // Could be stricter if options are strings
            return 'string';
        
        case 'number':
        case 'currency':
        case 'percent':
        case 'auto_number':
            return 'number';
        
        case 'boolean':
            return 'boolean';
            
        case 'date':
        case 'datetime':
        case 'time':
            return 'Date | string';
            
        case 'vector':
            return 'number[]';
            
        case 'file':
        case 'image':
            return field.multiple ? 'any[]' : 'any'; // Simplified for now
            
        case 'object':
        case 'location':
            return 'any';

        case 'lookup':
        case 'master_detail':
            return 'string | number'; // The ID

        default:
            return 'any';
    }
}

function toPascalCase(str: string): string {
    return str.replace(/(^\w|_\w)/g, m => m.replace('_', '').toUpperCase());
}
