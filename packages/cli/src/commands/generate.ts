import * as fs from 'fs';
import * as path from 'path';
import glob from 'fast-glob';
import * as yaml from 'js-yaml';
import { ObjectConfig, FieldConfig } from '@objectql/types';

export async function generateTypes(sourceDir: string, outputDir: string) {
    console.log(`Searching for objects in ${sourceDir}...`);
    
    const files = await glob(['**/*.object.yml', '**/*.object.yaml'], { 
        cwd: sourceDir,
        absolute: true,
        ignore: ['**/node_modules/**'] 
    });

    if (files.length === 0) {
        console.log('No object files found.');
        return;
    }

    // Ensure output dir exists
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    const indexContent: string[] = [];

    for (const file of files) {
        const content = fs.readFileSync(file, 'utf8');
        try {
            const schema = yaml.load(content) as ObjectConfig;
            if (!schema || !schema.name) continue;

            const typeName = toPascalCase(schema.name);
            const typeDefinition = generateInterface(typeName, schema);
            
            // Calculate relative directory structure
            // Ensure we handle absolute/relative path mismatch safely
            const absSourceDir = path.resolve(sourceDir);
            const relativePath = path.relative(absSourceDir, file);
            const relativeDir = path.dirname(relativePath);
            
            // Construct target directory
            const targetDir = path.join(outputDir, relativeDir);
            if (!fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
            }

            const outPath = path.join(targetDir, `${schema.name}.ts`);
            fs.writeFileSync(outPath, typeDefinition);
            console.log(`Generated ${path.join(relativeDir, schema.name)}.ts`);

            // Add to index (normalize path separators for imports)
            const importPath = path.join(relativeDir, schema.name).split(path.sep).join('/');
            // Use ./ prefix if distinct from dot
            const formatImport = importPath.startsWith('.') ? importPath : `./${importPath}`;
            indexContent.push(`export * from '${formatImport}';`);
        } catch (e) {
            console.error(`Failed to parse ${file}:`, e);
        }
    }

    // Generate index.ts
    fs.writeFileSync(path.join(outputDir, 'index.ts'), indexContent.join('\n'));
    console.log(`Generated types in ${outputDir}`);
}

function generateInterface(typeName: string, schema: ObjectConfig): string {
    const fields = schema.fields || {};
    const lines = [
        `// Auto-generated by ObjectQL. DO NOT EDIT.`,
        `import { ObjectDoc } from '@objectql/types';`, // Assuming a base type exists or we define it
        ``,
        `export interface ${typeName} extends ObjectDoc {`
    ];

    for (const [key, field] of Object.entries(fields)) {
        const fieldName = field.name || key;
        const isOptional = !field.required;
        const tsType = mapFieldTypeToTs(field);
        
        // Add JSDoc
        if (field.label || field.description) {
            lines.push(`    /**`);
            if (field.label) lines.push(`     * ${field.label}`);
            if (field.description) lines.push(`     * ${field.description}`);
            lines.push(`     */`);
        }
        
        lines.push(`    ${fieldName}${isOptional ? '?' : ''}: ${tsType};`);
    }

    lines.push(`}`);
    lines.push(``);
    return lines.join('\n');
}

function mapFieldTypeToTs(field: FieldConfig): string {
    switch (field.type) {
        case 'text':
        case 'textarea':
        case 'markdown':
        case 'html':
        case 'email':
        case 'phone':
        case 'url':
        case 'password':
        case 'select': // Could be stricter if options are strings
            return 'string';
        
        case 'number':
        case 'currency':
        case 'percent':
        case 'auto_number':
            return 'number';
        
        case 'boolean':
            return 'boolean';
            
        case 'date':
        case 'datetime':
        case 'time':
            return 'Date | string';
            
        case 'vector':
            return 'number[]';
            
        case 'file':
        case 'image':
            return field.multiple ? 'any[]' : 'any'; // Simplified for now
            
        case 'object':
        case 'location':
            return 'any';

        case 'lookup':
        case 'master_detail':
            return 'string | number'; // The ID

        default:
            return 'any';
    }
}

function toPascalCase(str: string): string {
    return str.replace(/(^\w|_\w)/g, m => m.replace('_', '').toUpperCase());
}
