# Introduction

**ObjectQL** is a protocol-first application engine. It rethinks backend development by treating everything—Data Models, Queries, and Logic—as **structured data** rather than code strings.

## The Core Philosophy

### 1. The JSON Protocol
In traditional development, you write SQL strings (`SELECT * FROM users`) or use fluent builders (`db.select('users')`).
In ObjectQL, the query **IS** the data structure.

```json
// Find users where age > 18
{
  "op": "find",
  "object": "user",
  "args": {
    "filters": [["age", ">", 18]]
  }
}
```

This makes the protocol:
*   **Universal**: Can be generated by any client (JS, Python, Swift, or LLMs).
*   **Serialization-ready**: Pass it over HTTP, WebSocket, or save it to a file.
*   **Secure**: Zero SQL injection risk by design.

### 2. Metadata as Source of Truth
Instead of defining TypeScript classes or SQL DDL, you define your business domain in declarative YAML.

```yaml
# user.object.yml
name: user
fields:
  email: { type: email, unique: true }
  role: { type: select, options: [admin, user] }
```

This metadata is loaded at runtime to:
*   Auto-generate database schemas (tables/collections).
*   Auto-generate TypeScript types.
*   Auto-validate incoming requests.

### 3. Logic as Graph
Your application logic isn't hidden inside controller functions. It's attached to the Graph as **Hooks** and **Actions**.

*   **Hook**: "When `user` is created, send email."
*   **Action**: "Expose RPC `resetPassword` on `user`."

## Why use ObjectQL?

*   **For AI**: It demands structured input/output, which fits AI Agent capabilities perfectly.
*   **For Low-Code**: The rigorous structure makes it easy to build UI visual editors on top of it.
*   **For Microservices**: The federation protocol allows you to stitch multiple services into one graph instantly.


*   [**CLI Tool**](./cli.md): Using the command line interface for codegen.
